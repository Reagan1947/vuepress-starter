# 泛型

## 1.1 泛型的概述和好处

### 1.泛型的概述

泛型：是 JDK5 中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型
它的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。

一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？
顾名思义，就是将类型由原来的具体类型参数化，然后再使用/调用时传入具体的类型
这种参数类型可以用在类、方法和接口中，分别称为泛型类、泛型方法、泛型接口。

泛型定义格式：

- < 类型 >：指定一种类型的格式。这里的类型可以看成是形参
- < 类型 1， 类型 2 ... >：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参
- 将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型

### 2. 泛型的好处

把运行时期的问题提前到了编译期间，避免了强制类型转换。

### 3. 参考代码

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * 需求：Collection 集合存储字符串并遍历
 */
public class GenericDemo {
    public static void main(String[] args) {
        // 创建集合对象
        // Collection c = new ArrayList();
        Collection<String> c = new ArrayList<>();

        // 添加元素
        c.add("hello");
        c.add("world");
        c.add("java");
        // c.add(100);

        // 遍历集合
        // Iterator iterator = c.iterator();
        Iterator<String> iterator = c.iterator();
        while (iterator.hasNext()) {
            // Object obj = iterator.next();
            // System.out.println(obj);
            // String s = (String) iterator.next();  // ClassCastException
            String s = iterator.next();
            System.out.println(s);
        }

    }
}
```

## 1.2 泛型类

### 1. 概述

泛型类的定义格式：
- 格式：`修饰符 class 类名<类型>{}`

- 范例：`public class Generic<T>{}`
  此处 T 可以随便写为任意标识，常见的如 T、E、K、V 等形式的参数常用于表示泛型
  
  

### 2. 参考代码

```java
/**
 * 测试类
 */
public class GenericDemo {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("Linda");
        System.out.println(s.getName());

        Teacher t = new Teacher();
        t.setAge(30);
        // t.setAge("30");
        System.out.println(t.getAge());
        System.out.println("-------");

        Generic<String> g1 = new Generic<>();
        g1.setT("Linda");
        System.out.println(g1.getT());

        Generic<Integer> g2 = new Generic<>();
        g2.setT(30);
        System.out.println(g2.getT());

        Generic<Boolean> g3 = new Generic<>();
        g3.setT(true);
        System.out.println(g3.getT());
    }
}
```

## 1.3 泛型方法

### 1.  概述

泛型方法的定义格式：
- 格式：修饰符 <类型> 返回值类型方法名(类型 变量名)

- 范例：`public <T> void show(T t) {}`

  

### 2. 参考代码

==Generic.==

```java
//public class Generic {
//    public void show(String s) {
//        System.out.println(s);
//    }
//
//    public void show(Integer i) {
//        System.out.println(i);
//    }
//
//    public void show(Boolean b) {
//        System.out.println(b);
//    }
//}

// 泛型类改进
//public class Generic<T> {
//    public void show(T t) {
//        System.out.println(t);
//    }
//}

// 泛型方法改进
public class Generic {
    public <T> void show(T t) {
        System.out.println(t);
    }
}
```

==GenericDemo==

```java
//public class Generic {
//    public void show(String s) {
//        System.out.println(s);
//    }
//
//    public void show(Integer i) {
//        System.out.println(i);
//    }
//
//    public void show(Boolean b) {
//        System.out.println(b);
//    }
//}

// 泛型类改进
//public class Generic<T> {
//    public void show(T t) {
//        System.out.println(t);
//    }
//}

// 泛型方法改进
public class Generic {
    public <T> void show(T t) {
        System.out.println(t);
    }
}
```

## 1.4 泛型接口

### 1. 概述

泛型接口的定义格式：
- 格式：修饰符 interface 接口名<类型>{ }

- 范例：`public interface Generic<T>{}`

  

### 2. 参考代码

==Generic==

```java
public interface Generic<T> {
    void show(T t);
}
```

==GenericDemo==

```java
public class GenericDemo {
    public static void main(String[] args) {
        Generic<String> g1 = new GenericImpl<String>();
        g1.show("Linda");

        Generic<Integer> g2 = new GenericImpl<Integer>();
        g2.show(30);
    }
}
```

==GenericImpl==

```java
public class GenericImpl<T> implements Generic<T>{
    @Override
    public void show(T t) {
        System.out.println(t);
    }
}
```

## 1.5 类型通配符

为了表示各种泛型 List 的父亲，可以使用类型通配符：
- 类型通配符：`<?>`

- `List<?>`：表示元素类型未知的 List，它的元素可以匹配任何类型

- 这种带通配符的 List 仅表示它是各种泛型 List 的父亲，并不能把元素添加其中

  <br>

如果说我们不希望 List<?> 是任何泛型 List 的父亲，只希望它代表某一类泛型 List 的父亲，可以使用类型通配符的上限。
- 类型通配符上限：<? extends 类型>

- List<? extends Number>：它表示的类型是 Number 或者其子类型

  <br>

除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限

- 