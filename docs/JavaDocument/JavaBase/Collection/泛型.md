## 1.6 泛型

### 1.6.1 泛型的概述和好处

#### 1. 泛型的概述

泛型：是 JDK5 中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型
它的本质是==参数化类型==，也就是说操作的数据类型被指定为一个参数

一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？
顾名思义，就是==将类型由原来的具体类型参数化，然后再使用/调用时传入具体的类型==
这种参数类型可以用在类、方法和接口中，分别称为泛型类、泛型方法、泛型接口

- 泛型定义格式

  - <类型>：指定一种类型的格式。这里的类型可以看成是形参
  - <类型1， 类型2...>：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参
  - 将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型

#### 2. 泛型的好处

- 把运行时期的问题提前到了编译期间
- 避免了强制类型转换

#### 3. 参考代码

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * 需求：Collection 集合存储字符串并遍历
 */
public class GenericDemo {
    public static void main(String[] args) {
        // 创建集合对象
        // Collection c = new ArrayList();
        Collection<String> c = new ArrayList<>();

        // 添加元素
        c.add("hello");
        c.add("world");
        c.add("java");
        // c.add(100);

        // 遍历集合
        // Iterator iterator = c.iterator();
        Iterator<String> iterator = c.iterator();
        while (iterator.hasNext()) {
            // Object obj = iterator.next();
            // System.out.println(obj);
            // String s = (String) iterator.next();  // ClassCastException
            String s = iterator.next();
            System.out.println(s);
        }

    }
}
```

### 1.6.2 泛型类

#### 1. 概述

- 泛型类的定义格式：
  - 格式：`修饰符 class 类名<类型>{ }`
  - 范例：`public class Generic<T>{ }`
    此处==T==可以随便写为任意标识，常见的如==T、E、K、V==等形式的参数常用于表示泛型

#### 2. 参考代码

```java
/**
 * 测试类
 */
public class GenericDemo {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("Linda");
        System.out.println(s.getName());

        Teacher t = new Teacher();
        t.setAge(30);
        // t.setAge("30");
        System.out.println(t.getAge());
        System.out.println("-------");

        Generic<String> g1 = new Generic<>();
        g1.setT("Linda");
        System.out.println(g1.getT());

        Generic<Integer> g2 = new Generic<>();
        g2.setT(30);
        System.out.println(g2.getT());

        Generic<Boolean> g3 = new Generic<>();
        g3.setT(true);
        System.out.println(g3.getT());
    }
}
```

### 1.6.3 泛型方法

#### 1. 概述

- 泛型方法的定义格式
  - 格式：修饰符 <类型> 返回值类型方法名(类型 变量名)
  - 范例：`public <T> void show(T t) { }`

#### 2. 参考代码

==Generic==

```java
//public class Generic {
//    public void show(String s) {
//        System.out.println(s);
//    }
//
//    public void show(Integer i) {
//        System.out.println(i);
//    }
//
//    public void show(Boolean b) {
//        System.out.println(b);
//    }
//}

// 泛型类改进
//public class Generic<T> {
//    public void show(T t) {
//        System.out.println(t);
//    }
//}

// 泛型方法改进
public class Generic {
    public <T> void show(T t) {
        System.out.println(t);
    }
}
```

==GenericDemo==

```java
//public class Generic {
//    public void show(String s) {
//        System.out.println(s);
//    }
//
//    public void show(Integer i) {
//        System.out.println(i);
//    }
//
//    public void show(Boolean b) {
//        System.out.println(b);
//    }
//}

// 泛型类改进
//public class Generic<T> {
//    public void show(T t) {
//        System.out.println(t);
//    }
//}

// 泛型方法改进
public class Generic {
    public <T> void show(T t) {
        System.out.println(t);
    }
}
```

### 1.6.4 泛型接口

#### 1. 概述

- 泛型接口的定义格式：
  - 格式：修饰符 interface 接口名<类型>{ }
  - 范例：`public interface Generic<T>{}`

#### 2. 参考代码

==Generic==

```java
public interface Generic<T> {
    void show(T t);
}
```

==GenericDemo==

```java
public class GenericDemo {
    public static void main(String[] args) {
        Generic<String> g1 = new GenericImpl<String>();
        g1.show("Linda");

        Generic<Integer> g2 = new GenericImpl<Integer>();
        g2.show(30);
    }
}
```

==GenericImpl==

```java
public class GenericImpl<T> implements Generic<T>{
    @Override
    public void show(T t) {
        System.out.println(t);
    }
}
```

### 1.6.5 类型通配符

- 为了表示各种泛型List的父亲，可以使用类型通配符
  - 类型通配符：==\<?\>==
  - `List<?>`：表示元素类型未知的List，它的元素可以匹配任何类型
  - 这种带通配符的List仅表示它是各种泛型List的父亲，并不能把元素添加其中

- 如果说我们不希望List<?>是任何泛型List的父亲，只希望它代表某一类泛型List的父亲，可以使用类型通配符的上限。
  - 类型通配符上限：<? extends 类型>
  - List<? extends Number>：它表示的类型是Number或者其子类型
- 除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限
- 